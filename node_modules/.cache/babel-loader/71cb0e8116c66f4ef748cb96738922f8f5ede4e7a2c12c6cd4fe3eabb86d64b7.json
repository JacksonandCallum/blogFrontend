{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../css/css\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\", \"../css/css\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"sass\", function (config) {\n    var cssMode = CodeMirror.mimeModes[\"text/css\"];\n    var propertyKeywords = cssMode.propertyKeywords || {},\n      colorKeywords = cssMode.colorKeywords || {},\n      valueKeywords = cssMode.valueKeywords || {},\n      fontProperties = cssMode.fontProperties || {};\n    function tokenRegexp(words) {\n      return new RegExp(\"^\" + words.join(\"|\"));\n    }\n    var keywords = [\"true\", \"false\", \"null\", \"auto\"];\n    var keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\n    var operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\", \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\", \"\\\\{\", \"\\\\}\", \":\"];\n    var opRegexp = tokenRegexp(operators);\n    var pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\n    var word;\n    function isEndLine(stream) {\n      return !stream.peek() || stream.match(/\\s+$/, false);\n    }\n    function urlTokens(stream, state) {\n      var ch = stream.peek();\n      if (ch === \")\") {\n        stream.next();\n        state.tokenizer = tokenBase;\n        return \"operator\";\n      } else if (ch === \"(\") {\n        stream.next();\n        stream.eatSpace();\n        return \"operator\";\n      } else if (ch === \"'\" || ch === '\"') {\n        state.tokenizer = buildStringTokenizer(stream.next());\n        return \"string\";\n      } else {\n        state.tokenizer = buildStringTokenizer(\")\", false);\n        return \"string\";\n      }\n    }\n    function comment(indentation, multiLine) {\n      return function (stream, state) {\n        if (stream.sol() && stream.indentation() <= indentation) {\n          state.tokenizer = tokenBase;\n          return tokenBase(stream, state);\n        }\n        if (multiLine && stream.skipTo(\"*/\")) {\n          stream.next();\n          stream.next();\n          state.tokenizer = tokenBase;\n        } else {\n          stream.skipToEnd();\n        }\n        return \"comment\";\n      };\n    }\n    function buildStringTokenizer(quote, greedy) {\n      if (greedy == null) {\n        greedy = true;\n      }\n      function stringTokenizer(stream, state) {\n        var nextChar = stream.next();\n        var peekChar = stream.peek();\n        var previousChar = stream.string.charAt(stream.pos - 2);\n        var endingString = nextChar !== \"\\\\\" && peekChar === quote || nextChar === quote && previousChar !== \"\\\\\";\n        if (endingString) {\n          if (nextChar !== quote && greedy) {\n            stream.next();\n          }\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          state.tokenizer = tokenBase;\n          return \"string\";\n        } else if (nextChar === \"#\" && peekChar === \"{\") {\n          state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n          stream.next();\n          return \"operator\";\n        } else {\n          return \"string\";\n        }\n      }\n      return stringTokenizer;\n    }\n    function buildInterpolationTokenizer(currentTokenizer) {\n      return function (stream, state) {\n        if (stream.peek() === \"}\") {\n          stream.next();\n          state.tokenizer = currentTokenizer;\n          return \"operator\";\n        } else {\n          return tokenBase(stream, state);\n        }\n      };\n    }\n    function indent(state) {\n      if (state.indentCount == 0) {\n        state.indentCount++;\n        var lastScopeOffset = state.scopes[0].offset;\n        var currentOffset = lastScopeOffset + config.indentUnit;\n        state.scopes.unshift({\n          offset: currentOffset\n        });\n      }\n    }\n    function dedent(state) {\n      if (state.scopes.length == 1) return;\n      state.scopes.shift();\n    }\n    function tokenBase(stream, state) {\n      var ch = stream.peek();\n\n      // Comment\n      if (stream.match(\"/*\")) {\n        state.tokenizer = comment(stream.indentation(), true);\n        return state.tokenizer(stream, state);\n      }\n      if (stream.match(\"//\")) {\n        state.tokenizer = comment(stream.indentation(), false);\n        return state.tokenizer(stream, state);\n      }\n\n      // Interpolation\n      if (stream.match(\"#{\")) {\n        state.tokenizer = buildInterpolationTokenizer(tokenBase);\n        return \"operator\";\n      }\n\n      // Strings\n      if (ch === '\"' || ch === \"'\") {\n        stream.next();\n        state.tokenizer = buildStringTokenizer(ch);\n        return \"string\";\n      }\n      if (!state.cursorHalf) {\n        // state.cursorHalf === 0\n        // first half i.e. before : for key-value pairs\n        // including selectors\n\n        if (ch === \"-\") {\n          if (stream.match(/^-\\w+-/)) {\n            return \"meta\";\n          }\n        }\n        if (ch === \".\") {\n          stream.next();\n          if (stream.match(/^[\\w-]+/)) {\n            indent(state);\n            return \"qualifier\";\n          } else if (stream.peek() === \"#\") {\n            indent(state);\n            return \"tag\";\n          }\n        }\n        if (ch === \"#\") {\n          stream.next();\n          // ID selectors\n          if (stream.match(/^[\\w-]+/)) {\n            indent(state);\n            return \"builtin\";\n          }\n          if (stream.peek() === \"#\") {\n            indent(state);\n            return \"tag\";\n          }\n        }\n\n        // Variables\n        if (ch === \"$\") {\n          stream.next();\n          stream.eatWhile(/[\\w-]/);\n          return \"variable-2\";\n        }\n\n        // Numbers\n        if (stream.match(/^-?[0-9\\.]+/)) return \"number\";\n\n        // Units\n        if (stream.match(/^(px|em|in)\\b/)) return \"unit\";\n        if (stream.match(keywordsRegexp)) return \"keyword\";\n        if (stream.match(/^url/) && stream.peek() === \"(\") {\n          state.tokenizer = urlTokens;\n          return \"atom\";\n        }\n        if (ch === \"=\") {\n          // Match shortcut mixin definition\n          if (stream.match(/^=[\\w-]+/)) {\n            indent(state);\n            return \"meta\";\n          }\n        }\n        if (ch === \"+\") {\n          // Match shortcut mixin definition\n          if (stream.match(/^\\+[\\w-]+/)) {\n            return \"variable-3\";\n          }\n        }\n        if (ch === \"@\") {\n          if (stream.match('@extend')) {\n            if (!stream.match(/\\s*[\\w]/)) dedent(state);\n          }\n        }\n\n        // Indent Directives\n        if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n          indent(state);\n          return \"def\";\n        }\n\n        // Other Directives\n        if (ch === \"@\") {\n          stream.next();\n          stream.eatWhile(/[\\w-]/);\n          return \"def\";\n        }\n        if (stream.eatWhile(/[\\w-]/)) {\n          if (stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/, false)) {\n            word = stream.current().toLowerCase();\n            var prop = state.prevProp + \"-\" + word;\n            if (propertyKeywords.hasOwnProperty(prop)) {\n              return \"property\";\n            } else if (propertyKeywords.hasOwnProperty(word)) {\n              state.prevProp = word;\n              return \"property\";\n            } else if (fontProperties.hasOwnProperty(word)) {\n              return \"property\";\n            }\n            return \"tag\";\n          } else if (stream.match(/ *:/, false)) {\n            indent(state);\n            state.cursorHalf = 1;\n            state.prevProp = stream.current().toLowerCase();\n            return \"property\";\n          } else if (stream.match(/ *,/, false)) {\n            return \"tag\";\n          } else {\n            indent(state);\n            return \"tag\";\n          }\n        }\n        if (ch === \":\") {\n          if (stream.match(pseudoElementsRegexp)) {\n            // could be a pseudo-element\n            return \"variable-3\";\n          }\n          stream.next();\n          state.cursorHalf = 1;\n          return \"operator\";\n        }\n      } // cursorHalf===0 ends here\n      else {\n        if (ch === \"#\") {\n          stream.next();\n          // Hex numbers\n          if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)) {\n            if (isEndLine(stream)) {\n              state.cursorHalf = 0;\n            }\n            return \"number\";\n          }\n        }\n\n        // Numbers\n        if (stream.match(/^-?[0-9\\.]+/)) {\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"number\";\n        }\n\n        // Units\n        if (stream.match(/^(px|em|in)\\b/)) {\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"unit\";\n        }\n        if (stream.match(keywordsRegexp)) {\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"keyword\";\n        }\n        if (stream.match(/^url/) && stream.peek() === \"(\") {\n          state.tokenizer = urlTokens;\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"atom\";\n        }\n\n        // Variables\n        if (ch === \"$\") {\n          stream.next();\n          stream.eatWhile(/[\\w-]/);\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"variable-2\";\n        }\n\n        // bang character for !important, !default, etc.\n        if (ch === \"!\") {\n          stream.next();\n          state.cursorHalf = 0;\n          return stream.match(/^[\\w]+/) ? \"keyword\" : \"operator\";\n        }\n        if (stream.match(opRegexp)) {\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"operator\";\n        }\n\n        // attributes\n        if (stream.eatWhile(/[\\w-]/)) {\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          word = stream.current().toLowerCase();\n          if (valueKeywords.hasOwnProperty(word)) {\n            return \"atom\";\n          } else if (colorKeywords.hasOwnProperty(word)) {\n            return \"keyword\";\n          } else if (propertyKeywords.hasOwnProperty(word)) {\n            state.prevProp = stream.current().toLowerCase();\n            return \"property\";\n          } else {\n            return \"tag\";\n          }\n        }\n\n        //stream.eatSpace();\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n          return null;\n        }\n      } // else ends here\n\n      if (stream.match(opRegexp)) return \"operator\";\n\n      // If we haven't returned by now, we move 1 character\n      // and return an error\n      stream.next();\n      return null;\n    }\n    function tokenLexer(stream, state) {\n      if (stream.sol()) state.indentCount = 0;\n      var style = state.tokenizer(stream, state);\n      var current = stream.current();\n      if (current === \"@return\" || current === \"}\") {\n        dedent(state);\n      }\n      if (style !== null) {\n        var startOfToken = stream.pos - current.length;\n        var withCurrentIndent = startOfToken + config.indentUnit * state.indentCount;\n        var newScopes = [];\n        for (var i = 0; i < state.scopes.length; i++) {\n          var scope = state.scopes[i];\n          if (scope.offset <= withCurrentIndent) newScopes.push(scope);\n        }\n        state.scopes = newScopes;\n      }\n      return style;\n    }\n    return {\n      startState: function () {\n        return {\n          tokenizer: tokenBase,\n          scopes: [{\n            offset: 0,\n            type: \"sass\"\n          }],\n          indentCount: 0,\n          cursorHalf: 0,\n          // cursor half tells us if cursor lies after (1)\n          // or before (0) colon (well... more or less)\n          definedVars: [],\n          definedMixins: []\n        };\n      },\n      token: function (stream, state) {\n        var style = tokenLexer(stream, state);\n        state.lastToken = {\n          style: style,\n          content: stream.current()\n        };\n        return style;\n      },\n      indent: function (state) {\n        return state.scopes[0].offset;\n      },\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\",\n      fold: \"indent\"\n    };\n  }, \"css\");\n  CodeMirror.defineMIME(\"text/x-sass\", \"sass\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","cssMode","mimeModes","propertyKeywords","colorKeywords","valueKeywords","fontProperties","tokenRegexp","words","RegExp","join","keywords","keywordsRegexp","operators","opRegexp","pseudoElementsRegexp","word","isEndLine","stream","peek","match","urlTokens","state","ch","next","tokenizer","tokenBase","eatSpace","buildStringTokenizer","comment","indentation","multiLine","sol","skipTo","skipToEnd","quote","greedy","stringTokenizer","nextChar","peekChar","previousChar","string","charAt","pos","endingString","cursorHalf","buildInterpolationTokenizer","currentTokenizer","indent","indentCount","lastScopeOffset","scopes","offset","currentOffset","indentUnit","unshift","dedent","length","shift","eatWhile","current","toLowerCase","prop","prevProp","hasOwnProperty","tokenLexer","style","startOfToken","withCurrentIndent","newScopes","i","scope","push","startState","type","definedVars","definedMixins","token","lastToken","content","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME"],"sources":["D:/Java_Projects/MYBLOG/frontend/blog-frontend/node_modules/codemirror/mode/sass/sass.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"sass\", function(config) {\n  var cssMode = CodeMirror.mimeModes[\"text/css\"];\n  var propertyKeywords = cssMode.propertyKeywords || {},\n      colorKeywords = cssMode.colorKeywords || {},\n      valueKeywords = cssMode.valueKeywords || {},\n      fontProperties = cssMode.fontProperties || {};\n\n  function tokenRegexp(words) {\n    return new RegExp(\"^\" + words.join(\"|\"));\n  }\n\n  var keywords = [\"true\", \"false\", \"null\", \"auto\"];\n  var keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\n\n  var operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\",\n                   \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\",\"\\\\{\",\"\\\\}\",\":\"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\n\n  var word;\n\n  function isEndLine(stream) {\n    return !stream.peek() || stream.match(/\\s+$/, false);\n  }\n\n  function urlTokens(stream, state) {\n    var ch = stream.peek();\n\n    if (ch === \")\") {\n      stream.next();\n      state.tokenizer = tokenBase;\n      return \"operator\";\n    } else if (ch === \"(\") {\n      stream.next();\n      stream.eatSpace();\n\n      return \"operator\";\n    } else if (ch === \"'\" || ch === '\"') {\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return \"string\";\n    } else {\n      state.tokenizer = buildStringTokenizer(\")\", false);\n      return \"string\";\n    }\n  }\n  function comment(indentation, multiLine) {\n    return function(stream, state) {\n      if (stream.sol() && stream.indentation() <= indentation) {\n        state.tokenizer = tokenBase;\n        return tokenBase(stream, state);\n      }\n\n      if (multiLine && stream.skipTo(\"*/\")) {\n        stream.next();\n        stream.next();\n        state.tokenizer = tokenBase;\n      } else {\n        stream.skipToEnd();\n      }\n\n      return \"comment\";\n    };\n  }\n\n  function buildStringTokenizer(quote, greedy) {\n    if (greedy == null) { greedy = true; }\n\n    function stringTokenizer(stream, state) {\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== \"\\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== \"\\\\\"));\n\n      if (endingString) {\n        if (nextChar !== quote && greedy) { stream.next(); }\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        state.tokenizer = tokenBase;\n        return \"string\";\n      } else if (nextChar === \"#\" && peekChar === \"{\") {\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return \"operator\";\n      } else {\n        return \"string\";\n      }\n    }\n\n    return stringTokenizer;\n  }\n\n  function buildInterpolationTokenizer(currentTokenizer) {\n    return function(stream, state) {\n      if (stream.peek() === \"}\") {\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return \"operator\";\n      } else {\n        return tokenBase(stream, state);\n      }\n    };\n  }\n\n  function indent(state) {\n    if (state.indentCount == 0) {\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  }\n\n  function dedent(state) {\n    if (state.scopes.length == 1) return;\n\n    state.scopes.shift();\n  }\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek();\n\n    // Comment\n    if (stream.match(\"/*\")) {\n      state.tokenizer = comment(stream.indentation(), true);\n      return state.tokenizer(stream, state);\n    }\n    if (stream.match(\"//\")) {\n      state.tokenizer = comment(stream.indentation(), false);\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match(\"#{\")) {\n      state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return \"operator\";\n    }\n\n    // Strings\n    if (ch === '\"' || ch === \"'\") {\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return \"string\";\n    }\n\n    if(!state.cursorHalf){// state.cursorHalf === 0\n    // first half i.e. before : for key-value pairs\n    // including selectors\n\n      if (ch === \"-\") {\n        if (stream.match(/^-\\w+-/)) {\n          return \"meta\";\n        }\n      }\n\n      if (ch === \".\") {\n        stream.next();\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"qualifier\";\n        } else if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if (ch === \"#\") {\n        stream.next();\n        // ID selectors\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"builtin\";\n        }\n        if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"variable-2\";\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/))\n        return \"number\";\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/))\n        return \"unit\";\n\n      if (stream.match(keywordsRegexp))\n        return \"keyword\";\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        return \"atom\";\n      }\n\n      if (ch === \"=\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^=[\\w-]+/)) {\n          indent(state);\n          return \"meta\";\n        }\n      }\n\n      if (ch === \"+\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^\\+[\\w-]+/)){\n          return \"variable-3\";\n        }\n      }\n\n      if(ch === \"@\"){\n        if(stream.match('@extend')){\n          if(!stream.match(/\\s*[\\w]/))\n            dedent(state);\n        }\n      }\n\n\n      // Indent Directives\n      if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n        indent(state);\n        return \"def\";\n      }\n\n      // Other Directives\n      if (ch === \"@\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"def\";\n      }\n\n      if (stream.eatWhile(/[\\w-]/)){\n        if(stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/,false)){\n          word = stream.current().toLowerCase();\n          var prop = state.prevProp + \"-\" + word;\n          if (propertyKeywords.hasOwnProperty(prop)) {\n            return \"property\";\n          } else if (propertyKeywords.hasOwnProperty(word)) {\n            state.prevProp = word;\n            return \"property\";\n          } else if (fontProperties.hasOwnProperty(word)) {\n            return \"property\";\n          }\n          return \"tag\";\n        }\n        else if(stream.match(/ *:/,false)){\n          indent(state);\n          state.cursorHalf = 1;\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        }\n        else if(stream.match(/ *,/,false)){\n          return \"tag\";\n        }\n        else{\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if(ch === \":\"){\n        if (stream.match(pseudoElementsRegexp)){ // could be a pseudo-element\n          return \"variable-3\";\n        }\n        stream.next();\n        state.cursorHalf=1;\n        return \"operator\";\n      }\n\n    } // cursorHalf===0 ends here\n    else{\n\n      if (ch === \"#\") {\n        stream.next();\n        // Hex numbers\n        if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"number\";\n        }\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"number\";\n      }\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"unit\";\n      }\n\n      if (stream.match(keywordsRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"keyword\";\n      }\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"atom\";\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"variable-2\";\n      }\n\n      // bang character for !important, !default, etc.\n      if (ch === \"!\") {\n        stream.next();\n        state.cursorHalf = 0;\n        return stream.match(/^[\\w]+/) ? \"keyword\": \"operator\";\n      }\n\n      if (stream.match(opRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"operator\";\n      }\n\n      // attributes\n      if (stream.eatWhile(/[\\w-]/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        word = stream.current().toLowerCase();\n        if (valueKeywords.hasOwnProperty(word)) {\n          return \"atom\";\n        } else if (colorKeywords.hasOwnProperty(word)) {\n          return \"keyword\";\n        } else if (propertyKeywords.hasOwnProperty(word)) {\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        } else {\n          return \"tag\";\n        }\n      }\n\n      //stream.eatSpace();\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n        return null;\n      }\n\n    } // else ends here\n\n    if (stream.match(opRegexp))\n      return \"operator\";\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  }\n\n  function tokenLexer(stream, state) {\n    if (stream.sol()) state.indentCount = 0;\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === \"@return\" || current === \"}\"){\n      dedent(state);\n    }\n\n    if (style !== null) {\n      var startOfToken = stream.pos - current.length;\n\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++) {\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent)\n          newScopes.push(scope);\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  }\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: \"sass\"}],\n        indentCount: 0,\n        cursorHalf: 0,  // cursor half tells us if cursor lies after (1)\n                        // or before (0) colon (well... more or less)\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    },\n\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\",\n    fold: \"indent\"\n  };\n}, \"css\");\n\nCodeMirror.defineMIME(\"text/x-sass\", \"sass\");\n\n});\n"],"mappings":";AAAA;AACA;;AAEA,CAAC,UAASA,GAAG,EAAE;EACb,IAAI,OAAOC,OAAO,IAAI,QAAQ,IAAI,OAAOC,MAAM,IAAI,QAAQ;IAAE;IAC3DF,GAAG,CAACG,OAAO,CAAC,sBAAsB,CAAC,EAAEA,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC,KACzD,IAAI,OAAOC,MAAM,IAAI,UAAU,IAAIA,MAAM,CAACC,GAAG;IAAE;IAClDD,MAAM,CAAC,CAAC,sBAAsB,EAAE,YAAY,CAAC,EAAEJ,GAAG,CAAC,CAAC;IACjD;IACHA,GAAG,CAACM,UAAU,CAAC;AACnB,CAAC,EAAE,UAASA,UAAU,EAAE;EACxB,YAAY;;EAEZA,UAAU,CAACC,UAAU,CAAC,MAAM,EAAE,UAASC,MAAM,EAAE;IAC7C,IAAIC,OAAO,GAAGH,UAAU,CAACI,SAAS,CAAC,UAAU,CAAC;IAC9C,IAAIC,gBAAgB,GAAGF,OAAO,CAACE,gBAAgB,IAAI,CAAC,CAAC;MACjDC,aAAa,GAAGH,OAAO,CAACG,aAAa,IAAI,CAAC,CAAC;MAC3CC,aAAa,GAAGJ,OAAO,CAACI,aAAa,IAAI,CAAC,CAAC;MAC3CC,cAAc,GAAGL,OAAO,CAACK,cAAc,IAAI,CAAC,CAAC;IAEjD,SAASC,WAAWA,CAACC,KAAK,EAAE;MAC1B,OAAO,IAAIC,MAAM,CAAC,GAAG,GAAGD,KAAK,CAACE,IAAI,CAAC,GAAG,CAAC,CAAC;IAC1C;IAEA,IAAIC,QAAQ,GAAG,CAAC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC;IAChD,IAAIC,cAAc,GAAG,IAAIH,MAAM,CAAC,GAAG,GAAGE,QAAQ,CAACD,IAAI,CAAC,GAAG,CAAC,CAAC;IAEzD,IAAIG,SAAS,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EACzD,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAC,KAAK,EAAC,KAAK,EAAC,GAAG,CAAC;IAClF,IAAIC,QAAQ,GAAGP,WAAW,CAACM,SAAS,CAAC;IAErC,IAAIE,oBAAoB,GAAG,sBAAsB;IAEjD,IAAIC,IAAI;IAER,SAASC,SAASA,CAACC,MAAM,EAAE;MACzB,OAAO,CAACA,MAAM,CAACC,IAAI,CAAC,CAAC,IAAID,MAAM,CAACE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC;IACtD;IAEA,SAASC,SAASA,CAACH,MAAM,EAAEI,KAAK,EAAE;MAChC,IAAIC,EAAE,GAAGL,MAAM,CAACC,IAAI,CAAC,CAAC;MAEtB,IAAII,EAAE,KAAK,GAAG,EAAE;QACdL,MAAM,CAACM,IAAI,CAAC,CAAC;QACbF,KAAK,CAACG,SAAS,GAAGC,SAAS;QAC3B,OAAO,UAAU;MACnB,CAAC,MAAM,IAAIH,EAAE,KAAK,GAAG,EAAE;QACrBL,MAAM,CAACM,IAAI,CAAC,CAAC;QACbN,MAAM,CAACS,QAAQ,CAAC,CAAC;QAEjB,OAAO,UAAU;MACnB,CAAC,MAAM,IAAIJ,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,GAAG,EAAE;QACnCD,KAAK,CAACG,SAAS,GAAGG,oBAAoB,CAACV,MAAM,CAACM,IAAI,CAAC,CAAC,CAAC;QACrD,OAAO,QAAQ;MACjB,CAAC,MAAM;QACLF,KAAK,CAACG,SAAS,GAAGG,oBAAoB,CAAC,GAAG,EAAE,KAAK,CAAC;QAClD,OAAO,QAAQ;MACjB;IACF;IACA,SAASC,OAAOA,CAACC,WAAW,EAAEC,SAAS,EAAE;MACvC,OAAO,UAASb,MAAM,EAAEI,KAAK,EAAE;QAC7B,IAAIJ,MAAM,CAACc,GAAG,CAAC,CAAC,IAAId,MAAM,CAACY,WAAW,CAAC,CAAC,IAAIA,WAAW,EAAE;UACvDR,KAAK,CAACG,SAAS,GAAGC,SAAS;UAC3B,OAAOA,SAAS,CAACR,MAAM,EAAEI,KAAK,CAAC;QACjC;QAEA,IAAIS,SAAS,IAAIb,MAAM,CAACe,MAAM,CAAC,IAAI,CAAC,EAAE;UACpCf,MAAM,CAACM,IAAI,CAAC,CAAC;UACbN,MAAM,CAACM,IAAI,CAAC,CAAC;UACbF,KAAK,CAACG,SAAS,GAAGC,SAAS;QAC7B,CAAC,MAAM;UACLR,MAAM,CAACgB,SAAS,CAAC,CAAC;QACpB;QAEA,OAAO,SAAS;MAClB,CAAC;IACH;IAEA,SAASN,oBAAoBA,CAACO,KAAK,EAAEC,MAAM,EAAE;MAC3C,IAAIA,MAAM,IAAI,IAAI,EAAE;QAAEA,MAAM,GAAG,IAAI;MAAE;MAErC,SAASC,eAAeA,CAACnB,MAAM,EAAEI,KAAK,EAAE;QACtC,IAAIgB,QAAQ,GAAGpB,MAAM,CAACM,IAAI,CAAC,CAAC;QAC5B,IAAIe,QAAQ,GAAGrB,MAAM,CAACC,IAAI,CAAC,CAAC;QAC5B,IAAIqB,YAAY,GAAGtB,MAAM,CAACuB,MAAM,CAACC,MAAM,CAACxB,MAAM,CAACyB,GAAG,GAAC,CAAC,CAAC;QAErD,IAAIC,YAAY,GAAKN,QAAQ,KAAK,IAAI,IAAIC,QAAQ,KAAKJ,KAAK,IAAMG,QAAQ,KAAKH,KAAK,IAAIK,YAAY,KAAK,IAAM;QAE/G,IAAII,YAAY,EAAE;UAChB,IAAIN,QAAQ,KAAKH,KAAK,IAAIC,MAAM,EAAE;YAAElB,MAAM,CAACM,IAAI,CAAC,CAAC;UAAE;UACnD,IAAIP,SAAS,CAACC,MAAM,CAAC,EAAE;YACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACtB;UACAvB,KAAK,CAACG,SAAS,GAAGC,SAAS;UAC3B,OAAO,QAAQ;QACjB,CAAC,MAAM,IAAIY,QAAQ,KAAK,GAAG,IAAIC,QAAQ,KAAK,GAAG,EAAE;UAC/CjB,KAAK,CAACG,SAAS,GAAGqB,2BAA2B,CAACT,eAAe,CAAC;UAC9DnB,MAAM,CAACM,IAAI,CAAC,CAAC;UACb,OAAO,UAAU;QACnB,CAAC,MAAM;UACL,OAAO,QAAQ;QACjB;MACF;MAEA,OAAOa,eAAe;IACxB;IAEA,SAASS,2BAA2BA,CAACC,gBAAgB,EAAE;MACrD,OAAO,UAAS7B,MAAM,EAAEI,KAAK,EAAE;QAC7B,IAAIJ,MAAM,CAACC,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;UACzBD,MAAM,CAACM,IAAI,CAAC,CAAC;UACbF,KAAK,CAACG,SAAS,GAAGsB,gBAAgB;UAClC,OAAO,UAAU;QACnB,CAAC,MAAM;UACL,OAAOrB,SAAS,CAACR,MAAM,EAAEI,KAAK,CAAC;QACjC;MACF,CAAC;IACH;IAEA,SAAS0B,MAAMA,CAAC1B,KAAK,EAAE;MACrB,IAAIA,KAAK,CAAC2B,WAAW,IAAI,CAAC,EAAE;QAC1B3B,KAAK,CAAC2B,WAAW,EAAE;QACnB,IAAIC,eAAe,GAAG5B,KAAK,CAAC6B,MAAM,CAAC,CAAC,CAAC,CAACC,MAAM;QAC5C,IAAIC,aAAa,GAAGH,eAAe,GAAGlD,MAAM,CAACsD,UAAU;QACvDhC,KAAK,CAAC6B,MAAM,CAACI,OAAO,CAAC;UAAEH,MAAM,EAACC;QAAc,CAAC,CAAC;MAChD;IACF;IAEA,SAASG,MAAMA,CAAClC,KAAK,EAAE;MACrB,IAAIA,KAAK,CAAC6B,MAAM,CAACM,MAAM,IAAI,CAAC,EAAE;MAE9BnC,KAAK,CAAC6B,MAAM,CAACO,KAAK,CAAC,CAAC;IACtB;IAEA,SAAShC,SAASA,CAACR,MAAM,EAAEI,KAAK,EAAE;MAChC,IAAIC,EAAE,GAAGL,MAAM,CAACC,IAAI,CAAC,CAAC;;MAEtB;MACA,IAAID,MAAM,CAACE,KAAK,CAAC,IAAI,CAAC,EAAE;QACtBE,KAAK,CAACG,SAAS,GAAGI,OAAO,CAACX,MAAM,CAACY,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC;QACrD,OAAOR,KAAK,CAACG,SAAS,CAACP,MAAM,EAAEI,KAAK,CAAC;MACvC;MACA,IAAIJ,MAAM,CAACE,KAAK,CAAC,IAAI,CAAC,EAAE;QACtBE,KAAK,CAACG,SAAS,GAAGI,OAAO,CAACX,MAAM,CAACY,WAAW,CAAC,CAAC,EAAE,KAAK,CAAC;QACtD,OAAOR,KAAK,CAACG,SAAS,CAACP,MAAM,EAAEI,KAAK,CAAC;MACvC;;MAEA;MACA,IAAIJ,MAAM,CAACE,KAAK,CAAC,IAAI,CAAC,EAAE;QACtBE,KAAK,CAACG,SAAS,GAAGqB,2BAA2B,CAACpB,SAAS,CAAC;QACxD,OAAO,UAAU;MACnB;;MAEA;MACA,IAAIH,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,GAAG,EAAE;QAC5BL,MAAM,CAACM,IAAI,CAAC,CAAC;QACbF,KAAK,CAACG,SAAS,GAAGG,oBAAoB,CAACL,EAAE,CAAC;QAC1C,OAAO,QAAQ;MACjB;MAEA,IAAG,CAACD,KAAK,CAACuB,UAAU,EAAC;QAAC;QACtB;QACA;;QAEE,IAAItB,EAAE,KAAK,GAAG,EAAE;UACd,IAAIL,MAAM,CAACE,KAAK,CAAC,QAAQ,CAAC,EAAE;YAC1B,OAAO,MAAM;UACf;QACF;QAEA,IAAIG,EAAE,KAAK,GAAG,EAAE;UACdL,MAAM,CAACM,IAAI,CAAC,CAAC;UACb,IAAIN,MAAM,CAACE,KAAK,CAAC,SAAS,CAAC,EAAE;YAC3B4B,MAAM,CAAC1B,KAAK,CAAC;YACb,OAAO,WAAW;UACpB,CAAC,MAAM,IAAIJ,MAAM,CAACC,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;YAChC6B,MAAM,CAAC1B,KAAK,CAAC;YACb,OAAO,KAAK;UACd;QACF;QAEA,IAAIC,EAAE,KAAK,GAAG,EAAE;UACdL,MAAM,CAACM,IAAI,CAAC,CAAC;UACb;UACA,IAAIN,MAAM,CAACE,KAAK,CAAC,SAAS,CAAC,EAAE;YAC3B4B,MAAM,CAAC1B,KAAK,CAAC;YACb,OAAO,SAAS;UAClB;UACA,IAAIJ,MAAM,CAACC,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;YACzB6B,MAAM,CAAC1B,KAAK,CAAC;YACb,OAAO,KAAK;UACd;QACF;;QAEA;QACA,IAAIC,EAAE,KAAK,GAAG,EAAE;UACdL,MAAM,CAACM,IAAI,CAAC,CAAC;UACbN,MAAM,CAACyC,QAAQ,CAAC,OAAO,CAAC;UACxB,OAAO,YAAY;QACrB;;QAEA;QACA,IAAIzC,MAAM,CAACE,KAAK,CAAC,aAAa,CAAC,EAC7B,OAAO,QAAQ;;QAEjB;QACA,IAAIF,MAAM,CAACE,KAAK,CAAC,eAAe,CAAC,EAC/B,OAAO,MAAM;QAEf,IAAIF,MAAM,CAACE,KAAK,CAACR,cAAc,CAAC,EAC9B,OAAO,SAAS;QAElB,IAAIM,MAAM,CAACE,KAAK,CAAC,MAAM,CAAC,IAAIF,MAAM,CAACC,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;UACjDG,KAAK,CAACG,SAAS,GAAGJ,SAAS;UAC3B,OAAO,MAAM;QACf;QAEA,IAAIE,EAAE,KAAK,GAAG,EAAE;UACd;UACA,IAAIL,MAAM,CAACE,KAAK,CAAC,UAAU,CAAC,EAAE;YAC5B4B,MAAM,CAAC1B,KAAK,CAAC;YACb,OAAO,MAAM;UACf;QACF;QAEA,IAAIC,EAAE,KAAK,GAAG,EAAE;UACd;UACA,IAAIL,MAAM,CAACE,KAAK,CAAC,WAAW,CAAC,EAAC;YAC5B,OAAO,YAAY;UACrB;QACF;QAEA,IAAGG,EAAE,KAAK,GAAG,EAAC;UACZ,IAAGL,MAAM,CAACE,KAAK,CAAC,SAAS,CAAC,EAAC;YACzB,IAAG,CAACF,MAAM,CAACE,KAAK,CAAC,SAAS,CAAC,EACzBoC,MAAM,CAAClC,KAAK,CAAC;UACjB;QACF;;QAGA;QACA,IAAIJ,MAAM,CAACE,KAAK,CAAC,yDAAyD,CAAC,EAAE;UAC3E4B,MAAM,CAAC1B,KAAK,CAAC;UACb,OAAO,KAAK;QACd;;QAEA;QACA,IAAIC,EAAE,KAAK,GAAG,EAAE;UACdL,MAAM,CAACM,IAAI,CAAC,CAAC;UACbN,MAAM,CAACyC,QAAQ,CAAC,OAAO,CAAC;UACxB,OAAO,KAAK;QACd;QAEA,IAAIzC,MAAM,CAACyC,QAAQ,CAAC,OAAO,CAAC,EAAC;UAC3B,IAAGzC,MAAM,CAACE,KAAK,CAAC,sBAAsB,EAAC,KAAK,CAAC,EAAC;YAC5CJ,IAAI,GAAGE,MAAM,CAAC0C,OAAO,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;YACrC,IAAIC,IAAI,GAAGxC,KAAK,CAACyC,QAAQ,GAAG,GAAG,GAAG/C,IAAI;YACtC,IAAIb,gBAAgB,CAAC6D,cAAc,CAACF,IAAI,CAAC,EAAE;cACzC,OAAO,UAAU;YACnB,CAAC,MAAM,IAAI3D,gBAAgB,CAAC6D,cAAc,CAAChD,IAAI,CAAC,EAAE;cAChDM,KAAK,CAACyC,QAAQ,GAAG/C,IAAI;cACrB,OAAO,UAAU;YACnB,CAAC,MAAM,IAAIV,cAAc,CAAC0D,cAAc,CAAChD,IAAI,CAAC,EAAE;cAC9C,OAAO,UAAU;YACnB;YACA,OAAO,KAAK;UACd,CAAC,MACI,IAAGE,MAAM,CAACE,KAAK,CAAC,KAAK,EAAC,KAAK,CAAC,EAAC;YAChC4B,MAAM,CAAC1B,KAAK,CAAC;YACbA,KAAK,CAACuB,UAAU,GAAG,CAAC;YACpBvB,KAAK,CAACyC,QAAQ,GAAG7C,MAAM,CAAC0C,OAAO,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;YAC/C,OAAO,UAAU;UACnB,CAAC,MACI,IAAG3C,MAAM,CAACE,KAAK,CAAC,KAAK,EAAC,KAAK,CAAC,EAAC;YAChC,OAAO,KAAK;UACd,CAAC,MACG;YACF4B,MAAM,CAAC1B,KAAK,CAAC;YACb,OAAO,KAAK;UACd;QACF;QAEA,IAAGC,EAAE,KAAK,GAAG,EAAC;UACZ,IAAIL,MAAM,CAACE,KAAK,CAACL,oBAAoB,CAAC,EAAC;YAAE;YACvC,OAAO,YAAY;UACrB;UACAG,MAAM,CAACM,IAAI,CAAC,CAAC;UACbF,KAAK,CAACuB,UAAU,GAAC,CAAC;UAClB,OAAO,UAAU;QACnB;MAEF,CAAC,CAAC;MAAA,KACE;QAEF,IAAItB,EAAE,KAAK,GAAG,EAAE;UACdL,MAAM,CAACM,IAAI,CAAC,CAAC;UACb;UACA,IAAIN,MAAM,CAACE,KAAK,CAAC,+BAA+B,CAAC,EAAC;YAChD,IAAIH,SAAS,CAACC,MAAM,CAAC,EAAE;cACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;YACtB;YACA,OAAO,QAAQ;UACjB;QACF;;QAEA;QACA,IAAI3B,MAAM,CAACE,KAAK,CAAC,aAAa,CAAC,EAAC;UAC9B,IAAIH,SAAS,CAACC,MAAM,CAAC,EAAE;YACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACtB;UACA,OAAO,QAAQ;QACjB;;QAEA;QACA,IAAI3B,MAAM,CAACE,KAAK,CAAC,eAAe,CAAC,EAAC;UAChC,IAAIH,SAAS,CAACC,MAAM,CAAC,EAAE;YACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACtB;UACA,OAAO,MAAM;QACf;QAEA,IAAI3B,MAAM,CAACE,KAAK,CAACR,cAAc,CAAC,EAAC;UAC/B,IAAIK,SAAS,CAACC,MAAM,CAAC,EAAE;YACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACtB;UACA,OAAO,SAAS;QAClB;QAEA,IAAI3B,MAAM,CAACE,KAAK,CAAC,MAAM,CAAC,IAAIF,MAAM,CAACC,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;UACjDG,KAAK,CAACG,SAAS,GAAGJ,SAAS;UAC3B,IAAIJ,SAAS,CAACC,MAAM,CAAC,EAAE;YACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACtB;UACA,OAAO,MAAM;QACf;;QAEA;QACA,IAAItB,EAAE,KAAK,GAAG,EAAE;UACdL,MAAM,CAACM,IAAI,CAAC,CAAC;UACbN,MAAM,CAACyC,QAAQ,CAAC,OAAO,CAAC;UACxB,IAAI1C,SAAS,CAACC,MAAM,CAAC,EAAE;YACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACtB;UACA,OAAO,YAAY;QACrB;;QAEA;QACA,IAAItB,EAAE,KAAK,GAAG,EAAE;UACdL,MAAM,CAACM,IAAI,CAAC,CAAC;UACbF,KAAK,CAACuB,UAAU,GAAG,CAAC;UACpB,OAAO3B,MAAM,CAACE,KAAK,CAAC,QAAQ,CAAC,GAAG,SAAS,GAAE,UAAU;QACvD;QAEA,IAAIF,MAAM,CAACE,KAAK,CAACN,QAAQ,CAAC,EAAC;UACzB,IAAIG,SAAS,CAACC,MAAM,CAAC,EAAE;YACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACtB;UACA,OAAO,UAAU;QACnB;;QAEA;QACA,IAAI3B,MAAM,CAACyC,QAAQ,CAAC,OAAO,CAAC,EAAE;UAC5B,IAAI1C,SAAS,CAACC,MAAM,CAAC,EAAE;YACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACtB;UACA7B,IAAI,GAAGE,MAAM,CAAC0C,OAAO,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UACrC,IAAIxD,aAAa,CAAC2D,cAAc,CAAChD,IAAI,CAAC,EAAE;YACtC,OAAO,MAAM;UACf,CAAC,MAAM,IAAIZ,aAAa,CAAC4D,cAAc,CAAChD,IAAI,CAAC,EAAE;YAC7C,OAAO,SAAS;UAClB,CAAC,MAAM,IAAIb,gBAAgB,CAAC6D,cAAc,CAAChD,IAAI,CAAC,EAAE;YAChDM,KAAK,CAACyC,QAAQ,GAAG7C,MAAM,CAAC0C,OAAO,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;YAC/C,OAAO,UAAU;UACnB,CAAC,MAAM;YACL,OAAO,KAAK;UACd;QACF;;QAEA;QACA,IAAI5C,SAAS,CAACC,MAAM,CAAC,EAAE;UACrBI,KAAK,CAACuB,UAAU,GAAG,CAAC;UACpB,OAAO,IAAI;QACb;MAEF,CAAC,CAAC;;MAEF,IAAI3B,MAAM,CAACE,KAAK,CAACN,QAAQ,CAAC,EACxB,OAAO,UAAU;;MAEnB;MACA;MACAI,MAAM,CAACM,IAAI,CAAC,CAAC;MACb,OAAO,IAAI;IACb;IAEA,SAASyC,UAAUA,CAAC/C,MAAM,EAAEI,KAAK,EAAE;MACjC,IAAIJ,MAAM,CAACc,GAAG,CAAC,CAAC,EAAEV,KAAK,CAAC2B,WAAW,GAAG,CAAC;MACvC,IAAIiB,KAAK,GAAG5C,KAAK,CAACG,SAAS,CAACP,MAAM,EAAEI,KAAK,CAAC;MAC1C,IAAIsC,OAAO,GAAG1C,MAAM,CAAC0C,OAAO,CAAC,CAAC;MAE9B,IAAIA,OAAO,KAAK,SAAS,IAAIA,OAAO,KAAK,GAAG,EAAC;QAC3CJ,MAAM,CAAClC,KAAK,CAAC;MACf;MAEA,IAAI4C,KAAK,KAAK,IAAI,EAAE;QAClB,IAAIC,YAAY,GAAGjD,MAAM,CAACyB,GAAG,GAAGiB,OAAO,CAACH,MAAM;QAE9C,IAAIW,iBAAiB,GAAGD,YAAY,GAAInE,MAAM,CAACsD,UAAU,GAAGhC,KAAK,CAAC2B,WAAY;QAE9E,IAAIoB,SAAS,GAAG,EAAE;QAElB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhD,KAAK,CAAC6B,MAAM,CAACM,MAAM,EAAEa,CAAC,EAAE,EAAE;UAC5C,IAAIC,KAAK,GAAGjD,KAAK,CAAC6B,MAAM,CAACmB,CAAC,CAAC;UAE3B,IAAIC,KAAK,CAACnB,MAAM,IAAIgB,iBAAiB,EACnCC,SAAS,CAACG,IAAI,CAACD,KAAK,CAAC;QACzB;QAEAjD,KAAK,CAAC6B,MAAM,GAAGkB,SAAS;MAC1B;MAGA,OAAOH,KAAK;IACd;IAEA,OAAO;MACLO,UAAU,EAAE,SAAAA,CAAA,EAAW;QACrB,OAAO;UACLhD,SAAS,EAAEC,SAAS;UACpByB,MAAM,EAAE,CAAC;YAACC,MAAM,EAAE,CAAC;YAAEsB,IAAI,EAAE;UAAM,CAAC,CAAC;UACnCzB,WAAW,EAAE,CAAC;UACdJ,UAAU,EAAE,CAAC;UAAG;UACA;UAChB8B,WAAW,EAAE,EAAE;UACfC,aAAa,EAAE;QACjB,CAAC;MACH,CAAC;MACDC,KAAK,EAAE,SAAAA,CAAS3D,MAAM,EAAEI,KAAK,EAAE;QAC7B,IAAI4C,KAAK,GAAGD,UAAU,CAAC/C,MAAM,EAAEI,KAAK,CAAC;QAErCA,KAAK,CAACwD,SAAS,GAAG;UAAEZ,KAAK,EAAEA,KAAK;UAAEa,OAAO,EAAE7D,MAAM,CAAC0C,OAAO,CAAC;QAAE,CAAC;QAE7D,OAAOM,KAAK;MACd,CAAC;MAEDlB,MAAM,EAAE,SAAAA,CAAS1B,KAAK,EAAE;QACtB,OAAOA,KAAK,CAAC6B,MAAM,CAAC,CAAC,CAAC,CAACC,MAAM;MAC/B,CAAC;MAED4B,iBAAiB,EAAE,IAAI;MACvBC,eAAe,EAAE,IAAI;MACrBC,WAAW,EAAE,IAAI;MACjBC,IAAI,EAAE;IACR,CAAC;EACH,CAAC,EAAE,KAAK,CAAC;EAETrF,UAAU,CAACsF,UAAU,CAAC,aAAa,EAAE,MAAM,CAAC;AAE5C,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}